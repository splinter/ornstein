var notify = require('notify');
var dhcLib = require('dhc-lib');
var http = require('http');
var chalk = require('chalk');
exports.run = function(opts) {
    var projectName = opts.projectDir;
    var requestList = [];
    var results = {};
    //Get the request list in the DHC project
    requestList = dhcLib.getRequests(projectName);
    //Invoke each request and run the associated tests
    requestList.forEach(function(definition, index) {
        definition = dhcLib.normalize(definition);
        perform(definition, projectName);
    });
};
var perform = function(definition, projectName) {
    invokeDHCRequest(definition, projectName);
    //invokeDHCTests(definition.name,projectName,definition);
};
var decomposeURI = function(uri) {
    var opts = {};
    var comps = uri.split('/');
    var base = comps[0];
    var path = comps.slice(1).join('/');
    var host = base.split(':');
    opts.host = host[0] || 'localhost';
    opts.port = host[1] || '80';
    opts.path = path;
    return opts;
};
var buildRequestOptions = function(definition) {
    var headerDirectives = definition.headers;
    var headers = {};
    var header;
    var opts = decomposeURI(definition.url);
    headerDirectives.forEach(function(headerInfo) {
        if (headerInfo.enabled) {
            headers[headerInfo.name] = headerInfo.value;
        }
    });
    return {
        method: definition.method,
        path: opts.path,
        host: opts.host,
        port: opts.port,
        headers: headers
    };
};
var print = function(msgs) {
    var str = msgs.reduce(function(previous, current) {
        return previous + ' ' + current.decorator(current.msg);
    }, '');
    console.log(str);
};
var printRequestDetails = function(options, definition, response) {
    //notify.info(options.method.toUpperCase() + ' ' + options.host + ':' + options.port + '/' + options.path);
    // notify.info('request options: '+JSON.stringify(options));
    // notify.info(JSON.stringify(definition));
    // notify.info('*****');
    var msgs = [];
    msgs.push({
        msg: '[Request:' + definition.name + ']',
        decorator: chalk.yellow
    });
    if (response) {
        msgs.push({
            msg: '[' + (response.statusCode >= 400) ? 'FAILED' : 'SUCCESS' + ']',
            decorator: (response.statusCode >= 400) ? chalk.bgRed : chalk.bgGreen
        });
    }
    msgs.push({
        msg: '[' + response.statusCode + ']',
        decorator: chalk.inverse
    });
    msgs.push({
        msg: options.method.toUpperCase(),
        decorator: chalk.inverse
    });
    msgs.push({
        msg: definition.schema + '://' + options.host + ':' + options.port + '/' + options.path,
        decorator: chalk.inverse.underline
    });
    print(msgs);
};
var printFailedRequestDetails = function(options, definition) {
    var msgs = [];
    msgs.push({
        msg: '[Request:' + definition.name + ']',
        decorator: chalk.yellow
    });
    msgs.push({
        msg: '[FAILED] Could not reach host! ',
        decorator: chalk.bgRed
    });
    msgs.push({
        msg: options.method.toUpperCase(),
        decorator: chalk.inverse
    });
    msgs.push({
        msg: definition.schema + '://' + options.host + ':' + options.port + '/' + options.path,
        decorator: chalk.inverse.underline
    });
    print(msgs);
};
var invokeDHCRequest = function(definition, projectName) {
    var opts = buildRequestOptions(definition);
    var req = http.request(opts, function(response) {
        var data = '';
        printRequestDetails(opts, definition, response);
        if (opts.method === 'POST') {
            //notify.info('[Sending POST data] for request::' + definition.name);
            //notify.info('\t\t' + definition.body);
        }
        response.on('data', function(str) {
            data += str;
        });
        response.on('end', function() {
            var input = {};
            input.headers = response.headers;
            input.content = data;
            console.log(chalk.grey('Response:'));
            console.log('\t' + chalk.grey(data));
            console.log(chalk.grey('Headers:'));
            console.log('\t' + chalk.grey(JSON.stringify(response.headers)));
            if (response.statusCode) {} else {
                notify.info('Starting testing');
                invokeDHCTests(definition.name, projectName, definition, input);
            }
        });
        response.on('error', function() {
            notify.error('test: ' + definition.name + ' failed.');
        });
    });
    req.on('error', function() {
        printFailedRequestDetails(opts, definition);
        //notify.error('Failed to invoke request: ' + definition.name);
        if (opts.method === 'POST') {
            console.log(chalk.grey('[POST data] for request::' + definition.name));
            console.log(chalk.grey('\t\t' + definition.body));
        }
    });
    if (opts.method === 'POST') {
        req.write(definition.body);
    }
    req.end();
};
var invokeDHCTests = function(requestName, projectName, definition, response) {
    var results = {};
    var result;
    var scriptName;
    var tests = dhcLib.getTestsForRequest(requestName, projectName);
    tests.forEach(function(testName) {
        var scriptPath = '../projects/' + projectName + '/' + testName;
        var script = require(scriptPath);
        executeTestScript(script, definition, response);
    });
};
var executeTestScript = function(script, req, res) {
    var result = {};
    for (var testName in script) {
        if (script.hasOwnProperty(testName)) {
            notify.info('Executing test ::  ' + testName);
            try {
                script[testName](req, res);
                result[testName] = {};
                result[testName].passed = true;
                notify.success('test: ' + testName + ' passed');
            } catch (e) {
                result[testName] = {};
                result[testName].passed = false;
                result[testName].result = e;
                notify.error('test: ' + testName + ' failed.');
            }
        }
    }
    return result;
};